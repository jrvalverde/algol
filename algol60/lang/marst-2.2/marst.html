<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from marst.texinfo on 1 December 2000 -->

<TITLE>GNU MARST 2.1 User's Guide</TITLE>
</HEAD>
<BODY>
<H1>GNU MARST</H1>
<H2>GNU Algol-to-C Translator</H2>
<H2>Version 2.1</H2>
<H2>User's Guide</H2>
<H2>December 2000</H2>
<ADDRESS>Andrew Makhorin</ADDRESS>
<P>
<P><HR><P>
<H1>Table of Contents</H1>
<UL>
<LI><A NAME="TOC1" HREF="marst.html#SEC1">Acknowledgements</A>
<LI><A NAME="TOC2" HREF="marst.html#SEC2">1. Introduction</A>
<LI><A NAME="TOC3" HREF="marst.html#SEC3">2. Installation</A>
<LI><A NAME="TOC4" HREF="marst.html#SEC4">3. Program Invocation</A>
<LI><A NAME="TOC5" HREF="marst.html#SEC5">4. Usage Example</A>
<LI><A NAME="TOC6" HREF="marst.html#SEC6">5. Input Language</A>
<LI><A NAME="TOC7" HREF="marst.html#SEC7">6. Input/Output</A>
<LI><A NAME="TOC8" HREF="marst.html#SEC8">7. Language Extensions</A>
<UL>
<LI><A NAME="TOC9" HREF="marst.html#SEC9">7.1 Modular programming</A>
<LI><A NAME="TOC10" HREF="marst.html#SEC10">7.2 Pseudo procedure <I>inline</I></A>
<LI><A NAME="TOC11" HREF="marst.html#SEC11">7.3 Pseudo procedure <I>print</I></A>
</UL>
<LI><A NAME="TOC12" HREF="marst.html#SEC12">8. Converter Utility</A>
</UL>
<P><HR><P>


<H1><A NAME="SEC1" HREF="marst.html#TOC1">Acknowledgements</A></H1>

<P>
The author thanks Erik Sch@"onfelder &#60;<A HREF="mailto:schoenfr@gaertner.de">schoenfr@gaertner.de</A>&#62; for a lot
of useful advices and especially for testing MARST with real Algol 60 programs.
The author also thanks Bernhard Treutwein
&#60;<A HREF="mailto:Bernhard.Treutwein@Verwaltung.Uni-Muenchen.DE">Bernhard.Treutwein@Verwaltung.Uni-Muenchen.DE</A>&#62; for great help in
preparing MARST documentation.




<H1><A NAME="SEC2" HREF="marst.html#TOC2">1. Introduction</A></H1>

<P>
GNU MARST is an Algol-to-C translator. It automatically translates programs
written in the algorithmic language Algol 60 into the ANSI C programming
language.


<P>
Processing scheme can be understood as the following:



<PRE>
                Algol-60 source program
                           |
                           V
                    +-------------+
                    |    MARST    |
                    +-------------+
                           |
                           V
                     C source code
                           |
                           V
                    +-------------+
     algol.h ------&#62;| C compiler  |&#60;------ Standard headers
                    +-------------+
                           |
                           V
                      Object code
                           |
                           V
                    +-------------+
      ALGLIB ------&#62;|   Linker    |&#60;------ Standard libraries
                    +-------------+
                           |
                           V
                    +-------------+
  Input data ------&#62;| Executable  |-------&#62; Output data
                    +-------------+
</PRE>

<P>
where:


<DL COMPACT>

<DT>Algol 60 source program
<DD>
a text file that contains a program written in the algorithmic language
Algol 60 (see below about coding requirements);
<DT>MARST
<DD>
the MARST translator, a program that converts source Algol program to the C
programming language. This program is a part of the MARST package;
<DT>C source code
<DD>
a text file that contains the C source code generated by the MARST translator;
<DT><CODE>algol.h</CODE>
<DD>
the header file that contains declarations of all objects used by every 
program generated by the MARST translator. This file includes some standard
headers (<CODE>stdio.h</CODE>, <CODE>stdlib.h</CODE>, etc.), however, no other headers are 
used explicitly in the generated code. This file is a part of the MARST
package;
<DT>Standard headers
<DD>
standard header files (they are used only in the header file <CODE>algol.h</CODE>);
<DT>C compiler
<DD>
C compiler;
<DT>Object code
<DD>
a binary file that contains object code produced by the C compiler;
<DT>ALGLIB
<DD>
the library (archive) file that contains object code for all standard and 
library routines used by Algol programs. Some of these routines, which 
correspond to standard Algol procedures (<I>ininteger</I>, <I>outreal</I>, etc.) are
written in Algol 60 and translated to the C programming language by means
of the MARST translator. Source code of all library routines is a part of the
MARST package. Note that the name of this library depends on a particular
distribution. In this distribution the library has the name <CODE>libalgol.a</CODE>;
<DT>Standard libraries
<DD>
standard C run-time libraries;
<DT>Linker
<DD>
external references resolving program;
<DT>Executable
<DD>
a binary file that contains ready-to-run Algol 60 program in the loadable
(executable) form;
<DT>Input data
<DD>
input text file(s) read by Algol program;
<DT>Output data
<DD>
output text file(s) written by Algol program.
</DL>



<H1><A NAME="SEC3" HREF="marst.html#TOC3">2. Installation</A></H1>

<P>
In order to install the MARST package under GNU/Linux the standard installation
procedure should be used. For details see the file <CODE>INSTALL</CODE> included into
the distribution.


<P>
As a result of installation the following four components will be installed:


<DL COMPACT>

<DT><CODE>marst</CODE>
<DD>
as a rule, into <CODE>usr/local/bin</CODE>;
<DT><CODE>macvt</CODE>
<DD>
as a rule, into <CODE>usr/local/bin</CODE>;
<DT><CODE>algol.h</CODE>
<DD>
as a rule, into <CODE>usr/local/include</CODE> and/or <CODE>usr/include</CODE>;
<DT><CODE>libalgol.a</CODE>
<DD>
as a rule, into <CODE>usr/local/lib</CODE>.
</DL>



<H1><A NAME="SEC4" HREF="marst.html#TOC4">3. Program Invocation</A></H1>

<P>
In order to invoke the MARST translator the following syntax should be used:


<P>
<CODE>marst</CODE> [<I>options</I> ...] [<I>filename</I>]


<P>
Options:


<DL COMPACT>

<DT><CODE>-d</CODE>, <CODE>--debug</CODE>
<DD>
run translator in debug mode

If this option is set, the translator emits elementary syntactic units of 
source Algol program to the output C code in the form of comments.

This option is useful for localizing syntax error more precisely. For example,
Algol 60 allows comments of three kinds: ordinary comments,
<B>end</B>-<B>end</B> comments, and extended parameter delimiters. Therefore, it
is easy to make a mistake, for example, forgetting a comma between the <B>end</B>
bracket and the next statement.

<DT><CODE>-e</CODE> <I>nnn</I>, <CODE>--error-max</CODE> <I>nnn</I>
<DD>
maximal error allowance

This option sets maximal error allowance. The translator stops processing after
the specified number of errors has been detected. The value of <I>nnn</I> should
be in the range from 0 to 255. If this option is not specified, the default
option <CODE>-e 0</CODE> is used and means that the translation is continued
until the end of the input file.

<DT><CODE>-h</CODE>, <CODE>--help</CODE>
<DD>
display help information and <CODE>exit(0)</CODE>

<DT><CODE>-l</CODE> <I>nnn</I>, <CODE>--linewidth</CODE> <I>nnn</I>
<DD>
desirable output line width

This option sets desirable line width for the output C code produced by the
translator. The value <I>nnn</I> should be in the range from 50 to 255. If this
option is not specified, the default option <CODE>-l 72</CODE> is used.

Note that actual line width may happen to be greater than <I>nnn</I>, because the
translator is not able to break the output text at any place. However, this 
happens relatively seldom.

<DT><CODE>-o</CODE> <I>filename</I>, <CODE>--output</CODE> <I>filename</I>
<DD>
the name of output text file, to which the translator sends the produced C code

If this option is not set, the translator uses the standard output by default.

<DT><CODE>-t</CODE>, <CODE>--notimestamp</CODE>
<DD>
don't write the time stamp to the output C code

By default the translator writes date and time of translation to the output C
code as a comment.

<DT><CODE>-v</CODE>, <CODE>--version</CODE>
<DD>
display translator version and <CODE>exit(0)</CODE>

<DT><CODE>-w</CODE>, <CODE>--nowarn</CODE>
<DD>
don't display warning messages

By default the translator displays warning messages that reflect potential 
errors and non-standard features used in the source Algol program.
</DL>

<P>
In order to translate a program written in Algol 60, it should be prepared
as a plain text file, and the name of this file should be specified in the
command line. If the name of the input text file is not specified, the
translator uses the standard input by default.


<P>
Note that the translator reads the input file <EM>twice</EM>, therefore this file
should be only regular file, but not a pipe, terminal input, etc. Thus, if the
standard input is used, it should be redirected to a regular file.


<P>
For one run the translator is able to process only one input text file.




<H1><A NAME="SEC5" HREF="marst.html#TOC5">4. Usage Example</A></H1>

<P>
The following example shows how the MARST translator may be used in most cases.


<P>
At first we prepare source Algol 60 program, say, in the text file named
<SAMP>`sample.alg'</SAMP>:



<PRE>
begin
   outstring(1, "Hello, world\n")
end
</PRE>

<P>
Now we translate this program to the C programming language:



<PRE>
marst sample.alg -o sample.c
</PRE>

<P>
and get the text file named <SAMP>`sample.c'</SAMP>, which then we compile and link in
the usual way (we should remember about Algol and math libraries):



<PRE>
gcc sample.c -lalgol -lm
</PRE>

<P>
Finally, we run executable



<PRE>
./sample
</PRE>

<P>
and see what we get. That's all.




<H1><A NAME="SEC6" HREF="marst.html#TOC6">5. Input Language</A></H1>

<P>
The input language of the MARST translator is hardware representation of the
reference language Algol 60 as described in the following IFIP document
<A NAME="DOCF1" HREF="marst.html#FOOT1">(1)</A>:


<P>
Modified Report on the Algorithmic Language ALGOL 60.
<I>The Computer Journal</I>, Vol. 19, No. 4, Nov. 1976,
pp. 364--79. (This document is an official IFIP standard. It is <EM>not</EM>
a part of the MARST package.)


<P>
Source Algol 60 program is coded as a plain text file using ASCII character
set.


<P>
Basic symbols should be coded as shown in the following table:



<PRE>
Basic symbol            Hardware representation
-----------------------------------------------
a, b, ..., z            a, b, ..., z
A, B, ..., Z            A, B, ..., Z
0, 1, ..., 9            0, 1, ..., 9
+                       +
-                       -
x                       *
/                       /
integer division        %
exponentiation          ^ (or **)
&#60;                       &#60;
not greater             &#60;=
=                       =
not less                &#62;=
&#62;                       &#62;
not equal               !=
equivalence             ==
implication             -&#62;
or                      |
and                     &#38;
not                     !
,                       ,
.                       .
ten (10)                # (pound sign)
:                       :
;                       ;
:=                      :=
(                       (
)                       )
[                       [
]                       ]
opening quote           "
closing quote           "
array                   array
begin                   begin
Boolean                 Boolean (or boolean)
code                    code
comment                 comment
do                      do
else                    else
end                     end
false                   false
for                     for
go to                   go to (or goto)
if                      if
integer                 integer
label                   label
own                     own
procedure               procedure
real                    real
step                    step
string                  string
switch                  switch
then                    then
true                    true
until                   until
value                   value
while                   while
</PRE>

<P>
Any symbol can be surrounded by any number of white-space characters (i.e. by
spaces, <CODE>HT</CODE>, <CODE>CR</CODE>, <CODE>LF</CODE>, <CODE>FF</CODE>, and <CODE>VT</CODE>). However,
any multi-character symbol should contain no white-space characters. Moreover,
a letter sequence is recognized as a keyword if and only if there is no letter
or digit that immediately precedes or follows the sequence (except the keyword
<SAMP>`go to'</SAMP> that may contain zero or more spaces between <SAMP>`go'</SAMP> and
<SAMP>`to'</SAMP>).


<P>
For example:


<DL COMPACT>

<DT><CODE>... 123 then abc ...</CODE>
<DD>
<SAMP>`then'</SAMP> will be recognized as <B>then</B> symbol
<DT><CODE>... 123then abc ...</CODE>
<DD>
<DT><CODE>... 123 thenabc ...</CODE>
<DD>
<SAMP>`then'</SAMP> will be recognized as letters <I>t</I>, <I>h</I>, <I>e</I>, <I>n</I>, but not
as <B>then</B> symbol
<DT><CODE>... 123 th en abc ...</CODE>
<DD>
<SAMP>`th en'</SAMP> will be recognized as letters <I>t</I>, <I>h</I>, <I>e</I>, <I>n</I>
</DL>

<P>
Note that identifiers and numbers can contain white-space characters. This
feature may be used in that case if an identifier is the same as keyword. For
example, identifier <I>label</I> should be coded as <SAMP>`la bel'</SAMP> or
<SAMP>`lab el'</SAMP>. Note also that white-space characters are not significant
(except their use within character strings), so <SAMP>`abc'</SAMP> and
<SAMP>`a b c'</SAMP> denote the same identifier <I>abc</I>.


<P>
All letters are case sensitive (except the first "b" in the keyword
<B>Boolean</B>). This means that <SAMP>`abc'</SAMP> and <SAMP>`ABC'</SAMP> are different
identifiers, and <SAMP>`Then'</SAMP> will not be recognized as the keyword <B>then</B>.


<P>
Each identifier or number can contain up to 100 characters (except internal
white-space characters).


<P>
Quoted character string are coded in the C style. For example:



<PRE>
outstring(1, "This\tis a string\n");

outstring(1, "This\tis a st"   "ring\n");

outstring(1, "This\tis all one st"
   "ring\n");
</PRE>

<P>
Within a string (i.e. between double quotes that enclose the string body)
escape sequences may be used (as <SAMP>`\t'</SAMP> and <SAMP>`\n'</SAMP> in the example
above). Double quote and backslash within string should be coded as <SAMP>`\"'</SAMP>
and <SAMP>`\\'</SAMP> respectively. Between parts of a string any number of
white-space characters is allowed.


<P>
Except coding character strings and limitation on length of identifiers and
numbers, there are no other differences between the syntax of the reference
language and the syntax of the MARST input language.


<P>
Note that there are some differences between the Revised Report on Algol 60
and the Modified Report on Algol 60, because the latter is a result of
application of the following IFIP document to the former:


<P>
<I>R. M. De Morgan, I. D. Hill, and B. A. Whichman.</I> A Supplement
to the ALGOL 60 Revised Report. <I>The Computer Journal</I>, Vol. 19,
No. 3, 1976, pp. 276--88. (This document is an official IFIP standard.
It is <EM>not</EM> a part of the MARST package.)


<P>
@ifnotinfo


<P>
In order to illustrate what is the input language of the MARST translator let's
consider the following procedure, which is written in the reference language:


<P>
This procedure may be coded using MARST representation as the following:



<PRE>
real procedure euler(fct, eps, tim);
   value eps, tim;
   real procedure fct; real eps; integer tim;
   comment euler computes the sum of fct(i) for i from zero up to
   infinity by means of a suitably refined euler transformation. The
   summation is stopped as soon as times in succession the absolute
   value of the terms of the transformed series are found to be less
   than eps. Hence one should provide a function fct with one integer
   argument, an upper bound eps, and an integer tim. euler is
   particularly efficient in the case of a slowly convergent or
   divergent alternating series;
   begin
   integer i, k, n, t;
   array m[0:15];
   real mn, mp, ds, sum;
   n := t := 0;
   m[0] := fct(0); sum := m[0] / 2;
   for i := 1, i+1 while t &#60; tim do
      begin
      mn := fct(i);
      for k := 0 step 1 until n do
         begin
         mp := (mn + m[k]) / 2;
         m[k] := mn; mn := mp
      end means;
   if abs(mn) &#60; abs(m[n]) &#38; n &#60; 15 then
      begin
      ds := mn / 2; n := n + 1;
      m[n] := mn
      end accept
   else
      ds := mn;
   sum := sum + ds;
   t := if abs(ds) &#60; eps then t + 1 else 0
   end;
euler := sum
end euler;   
</PRE>



<H1><A NAME="SEC7" HREF="marst.html#TOC7">6. Input/Output</A></H1>

<P>
All input/output is performed by standard Algol 60 procedures.


<P>
The MARST implementation provides up to 16 input/output channels, which have
numbers 0, 1, ..., 15. The channel number 0 is always connected to
<CODE>stdin</CODE>, so only input from this channel is allowed. Analogously, the
channel number 1 is always connected to <CODE>stdout</CODE>, so only output to this
channel is allowed. Other channels allow both input and output.


<P>
(The standard procedure <I>fault</I> uses the channel number
which is not available to the programmer. This latent channel is always
connected to <CODE>stderr</CODE>.)


<P>
Before Algol program startup all channels (except channels number 0 and 1) are
disconnected, i.e. no files are assigned to them.


<P>
If input (output) is required by the Algol program from (to) the channel number
<I>n</I>, the following actions are taken:



<OL>
<LI>

if the channel number <I>n</I> is connected for output (input), the I/O routine
closes the file assigned to this channel, making it be disconnected;
<LI>

if the channel number <I>n</I> is disconnected, the I/O routine opens the
corresponding file in read (write) mode and assigns this file to the channel,
making it be connected;
<LI>

finally, the I/O routine performs an input (an output) operation on the channel
number <I>n</I>. If an end-of-file has been detected, the I/O routine signals an
error condition.
</OL>

<P>
In order to determine the name of file, which should be assigned to the channel
number <I>n</I>, the I/O routine checks for environment variable named
<SAMP>`FILE_n'</SAMP>. If such variable exists, its value is used as filename.
Otherwise, its name (i.e. the character string <CODE>"FILE_n"</CODE>) is used as
filename.




<H1><A NAME="SEC8" HREF="marst.html#TOC8">7. Language Extensions</A></H1>

<P>
The MARST translator provides some extensions of the reference language in
order to make the package be more convenient for the programmer.




<H2><A NAME="SEC9" HREF="marst.html#TOC9">7.1 Modular programming</A></H2>

<P>
The feature of modular programming can be illustrated by the following example:



<PRE>
First file                    Second file
----------------------------------------------------
procedure one(a, b);          procedure one(a, b);
value a, b; real a, b;        value a, b; real a, b;
begin                         code;
      ...
end;                          procedure two(x, y);
                              value x, y; real x, y;
procedure two(x, y);          code;
value x, y; real x, y;
begin                         begin
      ...                           &#60;main program&#62;
end;                          end
</PRE>

<P>
The procedures <I>one</I> and <I>two</I> in the first file are called
<EM>precompiled procedures</EM>. Declarations of precompiled procedures should be
outside of main program block or compound statement. The procedures <I>one</I> and
<I>two</I> in the second file are called <EM>code procedures</EM>; they have the
keyword <B>code</B> instead a procedure body statement. Declarations of code
procedures also should be outside of main program block or compound statement.


<P>
This mechanism allows translating precompiled procedures independently from the
main program. Moreover, precompiled procedures may be programmed in any other
C compatible programming language. The programmer can consider that directly
before Algol program startup declarations of all precompiled procedures are
substituted into the file, which contains main program (the second file in the
example above), instead declarations of corresponding code procedures.


<P>
Each code procedure should have the same procedure heading as the corresponding
precompiled procedure (however, names of parameters may be altered). Note that
mismatched procedure headings can't be detected by the MARST translator,
because they are placed in different files.




<H2><A NAME="SEC10" HREF="marst.html#TOC10">7.2 Pseudo procedure <I>inline</I></A></H2>

<P>
The pseudo procedure <I>inline</I> has the following (implicit) heading:



<PRE>
procedure inline(str);
string str;
</PRE>

<P>
A procedure statement that refers to the <I>inline</I> pseudo procedure is
translated into the code, which is the string <I>str</I> without enclosing quotes.
For example:



<PRE>
Source program                  Output C code
------------------------------------------------
. . .                           . . .
a := 1;                         dsa_0-&#62;a_5 = 1;
b := 2;                         dsa_0-&#62;b_8 = 2;
inline("printf(\"OK\");");      printf("OK");
c := 3;                         dsa_0-&#62;c_4 = 3;
. . .                           . . .
</PRE>

<P>
Procedure statement <I>inline</I> may be used anywhere in the program as an
oridinary Algol statement.




<H2><A NAME="SEC11" HREF="marst.html#TOC11">7.3 Pseudo procedure <I>print</I></A></H2>

<P>
The pseudo procedure <I>print</I> is intended mainly for test printing (because
standard Algol input/output is out of criticism). This procedure has
unspecified heading and variable parameter list. For example:



<PRE>
real a, b; integer c; Boolean d;
array u, v[1:10], w[-5:5,-10:10];
. . .
print(a, b, u);
print(c);
. . .
print("test shot", (a+b)*c, !d &#38; u[1] &#62; v[1], u, v, w);
. . .
</PRE>

<P>
Each actual parameter passed to the pseudo procedure <I>print</I> is sent to the
channel number 1 (<CODE>stdout</CODE>) using printable format.




<H1><A NAME="SEC12" HREF="marst.html#TOC12">8. Converter Utility</A></H1>

<P>
Algol converter utility is MACVT. It is an auxiliary program, which is intended
for converting Algol 60 programs from some other representation to the
MARST representation. Such conversion is usually needed when existing Algol
programs should be adjusted in order to translate them with MARST.


<P>
MACVT is not a translator itself. This program just reads original code of
Algol 60 program from the input text file, converts main symbols to the
MARST representation (see Section 5. Input Language), and writes resulting code
to the output text file. It is assumed that the output code produced by MACVT
will be later translated by MARST in usual way. Note that MACVT performs no 
syntax checking.


<P>
Input language understood by MACVT differs from the MARST input language only
in representation of basic symbols. Should note that in this sense the MARST
input language is a subset of the MACVT input language.


<P>
Representation of basic symbols implemented in MACVT is based mainly on well
known (in 1960s) Algol 60 compiler developed by IBM first for IBM 7090 and
later for System/360. This representation may be considered as non-official
standard, because it was widely used at that time, when Algol 60 was actual
programming language.


<P>
In order to invoke the MACVT converter the following syntax should be used:


<P>
<CODE>macvt</CODE> [<I>options</I> ...] [<I>filename</I>]


<P>
Options:


<DL COMPACT>

<DT><CODE>-c</CODE>, <CODE>--classic</CODE>
<DD>
use classic representation

This option is used by default until other representation is chosen. It assumes
that input Algol 60 program is coded using classic representation: all
white-space characters are non-significant (except within quoted character
strings) and keywords should be enclosed by apostrophes. For details see below.

<DT><CODE>-f</CODE>, <CODE>--free-coding</CODE>
<DD>
use free representation

If this option is set, it is allowed not to enclose keywords by apostrophes. 
But in this case white-space characters should not be used within
multi-character basic symbols. See below for details.

<DT><CODE>-h</CODE>, <CODE>--help</CODE>
<DD>
display help information and <CODE>exit(0)</CODE>

<DT><CODE>-i</CODE>, <CODE>--ignore-case</CODE>
<DD>
convert letters to lower case

If this option is set, all letters (except within comments and character 
strings) are converted to lower case, i.e. conversion is case-insensitive.

<DT><CODE>-m</CODE>, <CODE>--more-free</CODE>
<DD>
use more free representation

This option is the same as <CODE>--free-coding</CODE>, but additionally keywords for
arithmetic, logical, and relational operators can be coded without apostrophes.
For details see below.

<DT><CODE>-o</CODE> <I>filename</I>, <CODE>--output</CODE> <I>filename</I>
<DD>
the name of output text file, to which the converter sends the converted 
Algol 60 program

If this option is not set, the converter uses the standard output by default.

<DT><CODE>-s</CODE>, <CODE>--old-sc</CODE>
<DD>
use old (classic) semicolon representation

This option allows the converter recognizing diphthong ., (point and comma) as
semicolon (including its usage for terminating comment sequence).

<DT><CODE>-t</CODE>, <CODE>--old-ten</CODE>
<DD>
use old (classic) ten symbol representation

This option allows the converter recognizing single apostrophe (when it is
followed by <CODE>+</CODE>, <CODE>-</CODE>, or digit) as ten symbol.

<DT><CODE>-v</CODE>, <CODE>--version</CODE>
<DD>
display the converter version and <CODE>exit(0)</CODE>
</DL>

<P>
In order to convert an Algol 60 program, it should be prepared as a plain text
file, and the name of this file should be specified in the command line. If the
name of the input text file is not specified, the converter uses the standard
input by default.


<P>
For one run the converter is able to process only one input text file.


<P>
In the table shown on the next page one or more valid representation are given
for each basic symbol. Thereto the following additional rules are assumed:



<OL>
<LI>

Classic (apostrophized) form of keywords and some other basic symbols are
allowed for any (i.e. for classic as well as free) representation.
<LI>

In case of classic representation all white-space characters (except their
usage within comments and quoted strings) are ignored anywhere.
<LI>

Basic symbol enclosed by apostrophes may contain white-space characters, which
are ignored. Besides, all letters are case-insensitive.
<LI>

Basic symbols may be coded in the free form (without apostrophes) only if the
free representation (<CODE>--free-coding</CODE> or <CODE>--more-free</CODE>) is used.
<LI>

In case of free representation any multi-character basic symbol should contain
no white-space characters.
<LI>

Free form of keywords that denote arithmetic, logical, and relational operators
(i.e. <CODE>greater</CODE> instead <CODE>'greater'</CODE>) is allowed only if the option
<CODE>--more-free</CODE> is used.
<LI>

Single apostrophe is recognized as ten symbol only if the option
<CODE>--old-ten</CODE> is used. Note that in this case the sequence <CODE>'10'</CODE> is
not recognized as ten symbol.
<LI>

Diphthong ., (point and comma) is recognized as semicolon only in the case if
the option <CODE>--old-sc</CODE> is used.
<LI>

If an opening quote is coded as <CODE>"</CODE> (double quote), the corresponding
closing quote should be coded as <CODE>"</CODE> (double quote). If an opening quote
is coded as <CODE>`</CODE> (diacritic mark), the corresponding closing quote should
be coded as <CODE>'</CODE> (single apostrophe).
</OL>


<PRE>
   Basic symbol            Extended hardware representation
   -----------------------------------------------------------
   a, b, ..., z            a, b, ..., z
   A, B, ..., Z            A, B, ..., Z
   0, 1, ..., 9            0, 1, ..., 9
   +                       +
   -                       -
   x                       *
   /                       /
   integer division        %                    '/'      'div'
   exponentiation          ^     **             'power'  'pow'
   &#60;                       &#60;                    'less'
   not greater             &#60;=                   'notgreater'
   =                       =                    'equal'
   not less                &#62;=                   'notless'
   &#62;                       &#62;                    'greater'
   not equal               !=                   'notequal'
   equivalence             ==                   'equiv'
   implication             -&#62;                   'impl'
   or                      |                    'or'
   and                     &#38;                    'and'
   not                     !                    'not'
   ,                       ,
   .                       .
   ten (10)                #     '              '10'
   :                       :     ..
   ;                       ;     .,
   :=                      :=    .=    ..=
   (                       (
   )                       )
   [                       [     (/
   ]                       ]     /)
   opening quote           "     `
   closing quote           "     '
   array                                        'array'
   begin                                        'begin'
   Boolean                                      'boolean'
   code                                         'code'
   comment                                      'comment'
   do                                           'do'
   else                                         'else'
   end                                          'end'
   false                                        'false'
   for                                          'for'
   go to                                        'goto'
   if                                           'if'
   integer                                      'integer'
   label                                        'label'
   own                                          'own'
   procedure                                    'procedure'
   real                                         'real'
   step                                         'step'
   string                                       'string'
   switch                                       'switch'
   then                                         'then'
   true                                         'true'
   until                                        'until'
   value                                        'value'
   while                                        'while'
</PRE>

<P>
In order to illustrate what the MACVT converter does, let us consider the
following Algol 60 procedure, which is coded using old (classic)
representation:



<PRE>
'PROCEDURE'EULER(FCT,SUM,EPS,TIM).,'VALUE'EPS,TIM.,
'INTEGER' TIM., 'REAL' 'PROCEDURE' FCT., 'REAL' SUM, EPS.,
'COMMENT' EULER COMPUTES THE SUM OF FCT (I) FOR I
 FROM ZERO UP TO INFINITY BY MEANS OF A SUITABLY
 REFINED EULER TRANSFORMATION. THE SUMMATION IS
 STOPPED AS SOON AS TIM TIMES IN SUCCESSION THE ABSOLUTE
 VALUE OF THE TERMS OF THE TRANSFORMED SERIES IS
 FOUND TO BE LESS THAN EPS, HENCE ONE SHOULD PROVIDE
 A FUNCTION FCT WITH ONE INTEGER ARGUMENT, AN UPPER
 BOUND EPS, AND AN INTEGER TIM. THE OUTPUT IS THE SUM SUM.
 EULER IS PARTICULARLY EFFICIENT IN THE CASE OF A SLOWLY
 CONVERGENT OR DIVERGENT ALTERNATING SERIES.,
 'BEGIN''INTEGER' I,K,N,T.,'ARRAY' M(/0..15/).,
 'REAL' MN, MP, DS.,
  I.=N.=T.=0.,M(/0/).=FCT(0).,SUM.=M(/0/)/2.,
  NEXTTERM..I.=I+1.,MN.=FCT(1).,
    'FOR' K.=0'STEP'1'UNTIL'N'DO'
         'BEGIN' MP.=(MN+M(/K/))/2.,M(/K/).=MN.,
            MN.=MP'END'MEANS.,
    'IF' (ABS(MN)'LESS' ABS (M(/N/))'AND'N'LESS'15)'THEN'
         'BEGIN'DS.=MN/2.,N.=N+1.,
            M(/N/).=MN'END' ACCEPT
         'ELSE' DS.=MN.,
          SUM.=SUM+DS.,
         'IF' ABS(DS)'LESS'EPS'THEN'T.=T+1'ELSE'T.=0.,
         'IF'T'LESS'TIM'THEN''GOTO'NEXTTERM
         'END'EULER;
</PRE>

<P>
We can convert this code to the MARST input language by means of the following
command:



<PRE>
macvt -i -s euler.alg -o euler1.alg
</PRE>

<P>
The verbatim result of conversion is the following:



<PRE>
procedure euler(fct,sum,eps,tim);value eps,tim;
integer tim; real procedure fct; real sum, eps;
comment EULER COMPUTES THE SUM OF FCT (I) FOR I
 FROM ZERO UP TO INFINITY BY MEANS OF A SUITABLY
 REFINED EULER TRANSFORMATION .THE SUMMATION IS
 STOPPED AS SOON AS TIM TIMES IN SUCCESSION THE ABSOLUTE
 VALUE OF THE TERMS OF THE TRANSFORMED SERIES IS
 FOUND TO BE LESS THAN EPS, HENCE ONE SHOULD PROVIDE
 A FUNCTION FCT WITH ONE INTEGER ARGUMENT, AN UPPER
 BOUND EPS, AND AN INTEGER TIM .THE OUTPUT IS THE SUM SUM
 .EULER IS PARTICULARLY EFFICIENT IN THE CASE OF A SLOWLY
 CONVERGENT OR DIVERGENT ALTERNATING SERIES;
 begin integer i,k,n,t;array m[0:15];
 real mn, mp, ds;
  i:=n:=t:=0;m[0]:=fct(0);sum:=m[0]/2;
  nextterm:i:=i+1;mn:=fct(1);
    for k:=0 step 1 until n do
         begin mp:=(mn+m[k])/2;m[k]:=mn;
            mn:=mp end means;
    if (abs(mn)&#60; abs (m[n])&#38;n&#60;15)then
         begin ds:=mn/2;n:=n+1;
            m[n]:=mn end accept
         else ds:=mn;
          sum:=sum+ds;
         if abs(ds)&#60;eps then t:=t+1 else t:=0;
         if t&#60;tim then go to nextterm
         end euler;
</PRE>

<P><HR><P>
<H1>Footnotes</H1>
<H3><A NAME="FOOT1" HREF="marst.html#DOCF1">(1)</A></H3>
<P>The verbatim reprint of this document may be obtained from the
author's page dedicated to the MARST package at
&#60;<A HREF="http://mai2.rcnet.ru/~mao/marst/index.htm">http://mai2.rcnet.ru/~mao/marst/index.htm</A>&#62;.
<P><HR><P>
This document was generated on 1 December 2000 using
<A HREF="http://wwwinfo.cern.ch/dis/texi2html/">texi2html</A>&nbsp;1.56k.
</BODY>
</HTML>
